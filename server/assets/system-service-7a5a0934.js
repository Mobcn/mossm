var b=Object.defineProperty;var _=(s,e,t)=>e in s?b(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var d=(s,e,t)=>(_(s,typeof e!="symbol"?e+"":e,t),t);import{s as u,a as w}from"./index-c5562bde.js";async function v(s){return(await fetch(s)).arrayBuffer()}async function k(s){return(await fetch(s)).text()}async function L(s){return(await fetch(s)).json()}const U=["width","height","fill"],E=["xlink:href"],O=Vue.defineComponent({__name:"MoIcon",props:{iconName:{},iconPathName:{default:"bootstrap"},width:{default:16},height:{default:16},fill:{default:"currentColor"}},setup(s){var n;const e=s,t=Vue.ref(((n=u.blobIconURL)==null?void 0:n[e.iconPathName])??""),r=Vue.computed(()=>`${t.value}#${e.iconName}`);return(async()=>{var o,a;if(t.value===""){const l="/setting/icons/icon.config.json",p="icon_config_cache@"+l;let i=await w.get(p);i??(i=await w.set(p,await L(l)));const c=i[e.iconPathName];(o=u).requestMap??(o.requestMap={}),(a=u.requestMap)[c]??(a[c]=fetch(c).then(f=>f.blob()).then(f=>{var y;const m=URL.createObjectURL(f);return(y=u).blobIconURL??(y.blobIconURL={}),u.blobIconURL[e.iconPathName]=m,m})),u.requestMap[c].then(f=>t.value=f)}})(),(o,a)=>(Vue.openBlock(),Vue.createElementBlock("svg",{width:o.width,height:o.height,fill:o.fill},[Vue.createElementVNode("use",{"xlink:href":Vue.unref(r)},null,8,E)],8,U))}}),j=(s,e)=>{const t=s.__vccOpts||s;for(const[r,n]of e)t[r]=n;return t};class g{constructor(e){d(this,"defaultOptions",{headers:{"Content-Type":"application/json"}});d(this,"requestInterceptors",[]);d(this,"responseInterceptors",[]);d(this,"responseErrorInterceptor",null);Object.assign(this.defaultOptions,e)}static create(e){return new g(e)}async get(e,t,r){return t&&(e=this.mergeURL(e,t)),this._request(e,void 0,{...r,method:"GET"})}async post(e,t,r){return this._request(e,t,{...r,method:"POST"})}async put(e,t,r){return this._request(e,t,{...r,method:"PUT"})}async delete(e,t,r){return t&&(e=this.mergeURL(e,t)),this._request(e,void 0,{...r,method:"DELETE"})}addRequestInterceptor(e){this.requestInterceptors.push(e)}addResponseInterceptor(e){this.responseInterceptors.push(e)}setResponseErrorInterceptor(e){this.responseErrorInterceptor=e}async _request(e,t,r){const n={...this.defaultOptions,body:t,...r};if(await this.runRequestInterceptors(e,n),typeof t=="object"?(n.headers=new Headers(n.headers),t instanceof FormData?n.headers.delete("Content-Type"):Object.keys(t).length>0&&((n.headers.get("Content-Type")??"").startsWith("application/x-www-form-urlencoded")?n.body=this.mergeURL("/",t).split("?")[1]:n.body=JSON.stringify(t))):t&&(n.body=t),n.timeout!==void 0){const i=new AbortController;n.signal&&(n.signal.onabort=c=>i.abort(c)),n.signal=i.signal,setTimeout(()=>i.abort("timeout"),n.timeout)}const o=await fetch(new URL(e,n.baseURL),n);if(o.status!==200){if(!this.responseErrorInterceptor)throw new Error(o.statusText);return await this.responseErrorInterceptor(o,n)}let a;const l=o.headers.get("Content-Type")??"";l.startsWith("application/json")?a=await o.json():l.startsWith("application/octet-stream")?a=await o.blob():a=await o.text();const p={...o,data:a};return await this.runResponseInterceptors(p),p.data}async runRequestInterceptors(e,t){for await(const r of this.requestInterceptors)await r(e,t)}async runResponseInterceptors(e){for await(const t of this.responseInterceptors){const r=await t(e);r&&(e.data=r)}}mergeURL(e,t){const r=new URL(e,"http://localhost");for(const[n,o]of Object.entries(t))o instanceof Array?o.forEach(a=>r.searchParams.append(n,String(a))):o&&r.searchParams.append(n,String(o));return e.startsWith("http")?r.href:r.href.replace("http://localhost","")}}const R="/mossm/login",h=g.create({baseURL:new URL(location.href).origin,timeout:1e4});h.addRequestInterceptor(async(s,e)=>{const t=await w.get("token");t&&(e.headers=new Headers(e.headers),e.headers.set("Authorization","Bearer "+t))});h.addResponseInterceptor(s=>{const{code:e,message:t,data:r}=s.data;if(e!==0)throw new Error(t);return r});h.setResponseErrorInterceptor(async(s,e)=>{if(s.status!==401)throw new Error(s.statusText);const{pathname:t}=new URL(s.url);if(t===R)throw new Error(s.statusText);let{token:r}=await h.post(R);return w.set("token",r),await h[e.method.toLowerCase()](s.url,void 0,e)});const I={login:"/mossm/login",chsetting:"/mossm/chsetting"},C={login:async(s,e)=>h.post(I.login,{username:s,password:e}),chsetting:async s=>h.post(I.chsetting,s)};export{O as _,j as a,v as b,k as c,C as d,L as l,h as s};
